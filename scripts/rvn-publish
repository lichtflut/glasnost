#!/usr/bin/env ruby
# encoding: UTF-8

require 'rubygems'
require 'net/https'
require 'json'
require 'optparse'

require_relative 'common/authenticate'
require_relative 'common/http_util'

# Parse command line options
options = {}
OptionParser.new do |opts|
  opts.banner = "Usage: rvn-publish [options]"
  opts.on("-v", "--verbose", "Run verbosely") do |v|
    options[:verbose] = v
  end
  opts.on("-u", "--user=USER", "User name") do |user|
    options[:user] = user
  end
  opts.on("-p", "--password=PASSWORD", "Password") do |password|
    options[:password] = password
  end
   opts.on("-d", "--domain=DOMAIN", "The domain") do |domain|
   options[:domain] = domain
  end
   opts.on("-c", "--context=CONTEXT", "The context") do |context|
   options[:context] = context
  end
  opts.on("-o", "--out=OUT", "Path to output file") do |out|
    options[:out] = out
  end
  opts.on("-b", "--base-uri=BASEURI", "Base URI of service") do |base_uri|
    options[:base_uri] = base_uri
  end
  opts.on("-i", "--in=IN", "Directory or file to publish") do |input|
    options[:in] = input
  end
  opts.on("-h", "--help", "Display this help") do |help|
    puts opts
    exit 0
  end
end.parse!

unless (options[:base_uri])
  abort("No base URI of service given. Use -h option to dispay help.")
end

if (options[:user].nil? ^ options[:password].nil?)
  $stderr.puts "Please provide both a user name *and* password using --user and --password."
  exit 5
end

unless (options[:context])
  options[:context] = 'default'
end

def handle_exception(uri, exception) 
  $stderr.puts "\n\nERROR in #{$0} trying to access \"#{uri}\": #{exception.to_s}\n#{exception.backtrace.join("\n")}\n\n"
end

def derive_context(dir, default)
  if ('metamodel' == File.basename(dir))
    return 'typesystem'
  else 
    return default
  end
end

def publish_vspec (base_uri, domain, vspec, token)
  uri   = URI.parse("#{base_uri}/service/domains/#{domain}/viewspecs/perspectives")
  puts "Publishing to URI: #{uri}"
  http  = init_http_object uri

  begin
    request = Net::HTTP::Post.new(uri.request_uri)
    request.add_field 'Cookie', "lfrb-session-auth=#{token}"
    File.open(vspec, 'r') do |infile|
      request.body = infile.read
    end
    response = http.request(request)
    puts "Response: #{response.code} #{response['Location']}"
  rescue OpenSSL::SSL::SSLError => exception    
    handle_exception(uri.to_s, exception)
  rescue JSON::ParserError => exception
    handle_exception(uri.to_s, exception)
  rescue Exception => exception
    handle_exception(uri.to_s, exception)
  end
end

def publish_schema (base_uri, domain, schema, token)
  uri   = URI.parse("#{base_uri}/service/domains/#{domain}/schemas")
  puts "Publishing to URI: #{uri}"
  http  = init_http_object uri

  begin
    request = Net::HTTP::Post.new(uri.request_uri)
    request.add_field 'Cookie', "lfrb-session-auth=#{token}"
    File.open(schema, 'r') do |infile|
      request.body = infile.read
    end
    response = http.request(request)
    puts "Response: #{response.code} #{response['Location']}"
  rescue OpenSSL::SSL::SSLError => exception
    handle_exception(uri.to_s, exception)
  rescue JSON::ParserError => exception
    handle_exception(uri.to_s, exception)
  rescue Exception => exception
    handle_exception(uri.to_s, exception)
  end
end

def publish_graph(base_uri, domain, context, graph, token)
  uri   = URI.parse("#{base_uri}/service/domains/#{domain}/graphs/context/#{context}")
  puts "Publishing to URI: #{uri}"
  http  = init_http_object uri

  begin
    request = Net::HTTP::Post.new(uri.request_uri)
    request.add_field 'Content-Type', 'application/xml'
    request.add_field 'Cookie', "lfrb-session-auth=#{token}"
    File.open(graph, 'r') do |infile|
      request.body = infile.read
    end
    response = http.request(request)
    puts "Response: #{response.code} #{response['Location']}"
  rescue OpenSSL::SSL::SSLError => exception
    handle_exception(uri.to_s, exception)
  rescue JSON::ParserError => exception
    handle_exception(uri.to_s, exception)
  rescue Exception => exception
    handle_exception(uri.to_s, exception)
  end
end

def publish_file (base_uri, domain, context, file, token) 
  case File.extname(file)
  when '.vspec'
    publish_vspec(base_uri, domain, file, token)
  when '.rsf'
    publish_schema(base_uri, domain, file, token)
  when '.xml'
    publish_graph(base_uri, domain, context, file, token)
  else
    $stderr.puts "Not a valid file (extension): #{file}"
  end
end

def publish_dir (base_uri, domain, context, dir_name, token) 
  dir = Dir.new dir_name
  context = derive_context(dir, context)
  puts "Publishing directory #{File.expand_path dir}"
  dir.entries.select{ |c| !c.start_with? '.' }. each do |c| 
    entry = File.join(dir,c)
    puts "Current entry #{entry}"
    if File.directory?(entry)
      publish_dir base_uri, domain, context, entry, token
    else
      publish_file base_uri, domain, context, entry, token
    end
  end
end

# BEGIN

user_ctx = UserCtx.new options[:user], options[:password]
user_ctx.authenticate options[:base_uri]

if File.directory?(options[:in])
  publish_dir options[:base_uri], options[:domain], options[:context], options[:in], user_ctx.token
else
  publish_file options[:base_uri], options[:domain], options[:context], options[:in], user_ctx.token
end





